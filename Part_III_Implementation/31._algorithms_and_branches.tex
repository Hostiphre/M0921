
\chapter{Algorithms and Branches\label{chpt:algorithms-and-branches}}

According to the commutativity of operations (see $\mathsection$\ref{sub:Commutativity-between-operations}),
the only possible algorithms to evaluate $\gamma(\mathbf{r},\mathbf{\Omega})$
from $\Delta\rho(\mathbf{r},\mathbf{\Omega})$ are shown in the figure
\ref{fig:Possible-algorithms}.

\begin{figure}[h]
\begin{centering}
\includegraphics{_figure/algorithms}
\par\end{centering}

\caption{Possible algorithms for $\gamma$ evaluation\label{fig:Possible-algorithms}}
\end{figure}


Several branches are built to test and compare between algorithms,
which are shown below in table \ref{tab:Branch-option} and will be
detailed in the following context. \marginpar{These branches should give numerically the same result in certain
conditions, that will be discussed in later sections.}

\selectlanguage{english}%
\begin{table}[h]
\selectlanguage{american}%
\begin{centering}
\begin{tabular*}{1\textwidth}{@{\extracolsep{\fill}}cccc}
\toprule 
\tableheadline{Method} & \tableheadline{Sub-Method} & \tableheadline{Description} & \tableheadline{Theory}\tabularnewline
\midrule
reference & dipole & calculate $n(r)$ and $P(r)$ separately & $\mathsection$\ref{chpt:mdft} \textcolor{red}{{[}ref{]}}\tabularnewline
\midrule
naive & standard & use $c_{\mu\nu,\chi}^{mn}(k)$ as input DCF & $\mathsection$\ref{sub:Using-projections-in-1}\tabularnewline
 & zero-order & use $\hat{c}(k,\boldsymbol{\omega_{1}},\boldsymbol{\omega_{2}})$
and take the nearest point & $\mathsection$\ref{sub:Zero-order-interpolation-of}\tabularnewline
 & interpolation & use $\hat{c}(k,\boldsymbol{\omega_{1}},\boldsymbol{\omega_{2}})$
with linear interpolation  & $\mathsection$\ref{sub:Linear-interpolation-of}\tabularnewline
 & dipole & use $c_{S}$, $c_{\Delta}$, $c_{D}$ issue from \textcolor{red}{{[}ref{]}} & $\mathsection$\ref{sub:Using-projections-in}\tabularnewline
 & nmax1 & use $c_{S}$, $c_{\Delta}$, $c_{D}$, $c_{\pm}$ issue from \textcolor{red}{{[}ref{]}} & $\mathsection$\ref{sub:Using-projections-in}\tabularnewline
\midrule
convolution & standard & algorithm with symmetry reduction & $\mathsection$\ref{sub:Reduction-by-symmetry}\tabularnewline
 & asymm  & algorithm without symmetry reduction & $\mathsection$\ref{sub:Reduction-by-symmetry}\tabularnewline
 & pure\_angular  & inverse FFT and FGSHT & $\mathsection$\ref{chpt:algorithms-and-branches}\tabularnewline
\bottomrule
\end{tabular*}
\par\end{centering}

\selectlanguage{english}%
\caption{\selectlanguage{american}%
Branch option in MDFT\label{tab:Branch-option}\selectlanguage{american}%
}
\end{table}


\selectlanguage{american}%

\section{Branches \textquotedbl{}naive\textquotedbl{} }

Branches \texttt{\textbf{naive}} are the algorithms mentioned in section
\ref{chpt:fft-spatial}, which go through the path 
\[
\left(b\right)\shortrightarrow\left(h\right)\shortrightarrow\left(p\right)
\]
 in figure \ref{fig:Possible-algorithms}, calculating directly $\hat{\gamma}(\mathbf{k},\mathbf{\Omega})$
from $\Delta\hat{\rho}(\mathbf{k},\mathbf{\Omega})$. The difference
between branches is the way to calculate $\hat{c}(\mathbf{k},\mathbf{\Omega_{1}},\mathbf{\Omega_{2}})$.
Branch\textbf{ }\texttt{\textbf{naive\_standard}} use $c_{\mu\nu,\chi}^{mn}(k)$
as input \acs{DCF}. Branch \texttt{\textbf{naive\_zero-order}} and
\texttt{\textbf{naive\_interpolation}} using $\hat{c}(k,\boldsymbol{\omega_{1}},\boldsymbol{\omega_{2}})$
with zero-order and linear interpolation, where the former is rejected
in the implementation due to a lack of precision (appendix \ref{chpt:error-evaluation-interpolation-DCF}).

The discussion of the accuracy to transform c projection to c table
is given in section ...

As one is constant other has a $O(N^{3})$ dependence on $n_{\max}$,
the discussion between the computing performance and memory usage
with respect to $n_{\max}$ and it will be given in section ...


\section{Branches \textquotedbl{}convolution\textquotedbl{}}

Branches\textbf{ }\texttt{\textbf{convolution\_asymm}} and \texttt{\textbf{convolution\_standard}}
are operational algorithms of angular convolution show in section
\ref{chpt:angular-convolution}, which go through the path 
\[
\left(a\right)\shortrightarrow\left(c\right)\shortrightarrow\left(f\right)\shortrightarrow\left(j\right)\shortrightarrow\left(n\right)\shortrightarrow\left(q\right)\shortrightarrow\left(r\right)
\]


Branches\textbf{ }\texttt{\textbf{convolution\_asymm}} uses the original
operational algorithm ($\mathsection$\ref{sec:Operational-algorithm})
without symmetry reduction ($\mathsection$\ref{sub:Reduction-by-symmetry}),
and \texttt{\textbf{convolution\_standard}} without it. 

Branch \texttt{\textbf{convolution\_pure\_angular}} goes through the
path 
\[
\left(b\right)\shortrightarrow\left(d\right)\shortrightarrow\left(f\right)\shortrightarrow\left(j\right)\shortrightarrow\left(n\right)\shortrightarrow\left(o\right)\shortrightarrow\left(p\right)
\]
which inverse the first and last two steps of the two algorithms mentioned
above.

mathematically 

a discussion the comparison of computing speed in in section ...


\section{Testing branches for nmax=1}

Branches \texttt{\textbf{naive\_dipole}}, \texttt{\textbf{naive\_nmax1}}
pass by $\left(b\right)\shortrightarrow\left(h\right)\shortrightarrow\left(p\right)$
, using DCF separately in reference \textcolor{red}{{[}ref{]}} and
\textcolor{red}{{[}ref{]}}, whose slight difference is shown in $\mathsection$\ref{sub:Comparison-with-non-coupling}.
Branch \texttt{\textbf{reference\_dipole}} use DCF in \textcolor{red}{{[}ref{]}},
which is the original method in MDFT to calculate $\mathcal{F}_{\mathrm{exc}}$
via multipole expansion. In addition with branch \texttt{\textbf{convolution\_standard}},
which can also use the two DCF mentioned above, a test of validation
can be performed ($\mathsection$), which should at any case exactly
numerically the same if the same DCF is used.


\section{Other paths}

There will also be a discussion of other paths, such as those passes
by $\left(i\right)$ and $\left(k\right)$, of their accuracy ($\mathsection$),
and of the computing cost ($\mathsection$).
